%!TEX root = ../Peerbox.tex

As illustrated in Figure~\ref{fig:figures_archOverview} the Peerbox client is structured according to the layered approach. The Middleware-layer is concerned about low level network communication. The Logic layer provides the functionality for the VirtualFileSystem and contains the application logic. The UI represents the user layer and provides the functionality for user interaction.

\begin{figure}[htbp]
    \centering
        \includegraphics[height=2in]{figures/archOverview.pdf}
    \caption{Architectural overview}
    \label{fig:figures_archOverview}
\end{figure}

We have decided to use two different channels for communication. The general peerbox related communication uses multicast message to a certain group, while File Transmission is implemented by using a 1-1 direct channel. 
The reason for that is that files are arbitrary large and would produce a lot of messages that need to be multicasted. Furthermore, not all clients might be interested in every file. Last but not least, a direct channel is fast and reliable as we can rely on the build-in properties of the TCP/IP protocol. 

\subsection{Middleware}

The middleware of peerbox uses IP-Multicast to announce messages to a group. However, basic multicast is not reliable as it does not ensure the transmission of a message or correct ordering of messages. 
Therefore, we need additional coordination and agreements on message receiving and delivery in form of a reliable multicast protocol.

% open vs. closed group 
%  only members can send to group, a member delivers to itself 
%  they are useful for coordination of groups of cooperating servers


The multicast protocol should ensure that all messages send to a group are eventually received and consumed by all process that are member of this group. Furthermore, messages need to be consumed in order, so that a file cannot be deleted before it has been created. 

For peerbox it is enough to ensure FIFO-ordering. Since a file always has a specific owner, it is enough if the messages from one process are consumed in order and independent from another process (no causality required). 



% % The IP address 224.0.0.0 through 239.255.255.255 are reserved for multicasts. The user needs to set some properties such as Path, Multicast address, Multicast port, Server Port and the name of the computer.



properties
Integrity - duplicate messages detected and rejected.
IP multicast uses checksums to reject corrupt messages
Validity - due to IP multicast in which sender delivers to 
itself
Agreement - processes can detect missing messages. 
They must keep copies of messages they have 
delivered so that they can re-transmit them to others.
discarding of copies of messages that are no longer 
needed : 
when piggybacked acknowledgements arrive, note which processes 
have received messages. When all processes in g have the message, 
discard it.
problem of a process that stops sending - use ‘heartbeat’ messages.

however ip multicast is per se unreliable, early test have shown a miss rate of 20\%

over udp datagram

negative acknowledgements

reliable multicast

additional checksum to verify payload

Operations 
multicast(g, m) sends message m to all members of process group g
deliver (m) is called to get a multicast message delivered. It is different 
from receive as it may be delayed to allow for ordering or reliability.

\subsubsection{Messages}

%figure message package

command can be either Message (1), ACK(2) or NACK(4). 
Acks are not used in this implementation in order to reduce traffic on the channel 

the size of the payload is dynamic though it is not allowed to be larger than the maximum message size, which is in our case preset to $2^15$. A fixed message size is important in order to determine the number of sizes from incoming messages. 


However, if the logic needs to send a lot of data, it can be split onto multiple messages (due to the reliable multicast it is guaranteed that all messages will eventually arrive and are consumed in order).


\subsubsection{Delivering Messages form Group}


\begin{figure}[htbp]
    \centering
        \includegraphics[width=.9\textwidth]{figures/message.pdf}
    \caption{Structure of a message}
    \label{fig:figures_announcement}
\end{figure}

use of resources  is indicated by a dashed line 
processes are divided by swim-lanes (dotted vertical lines)

\begin{figure}[htbp]
    \centering
        \includegraphics[height=4.5in]{figures/receivePackets.pdf}
    \caption{Listen for incoming multicast messages}
    \label{fig:figures_processReceivePackage}
\end{figure}

decoupled listener and processing to decouple lengthy processing from receivings

\begin{figure}[htbp]
    \centering
        \includegraphics[height=4.5in]{figures/processMessages.pdf}
    \caption{Process incoming multicast messages}
    \label{fig:figures_processMessages}
\end{figure}

eventually delivers it


\subsubsection{Sending Messages to Group}

\begin{figure}[htbp]
    \centering
        \includegraphics[height=3in]{figures/sendMessage.pdf}
    \caption{Send a multicast message}
    \label{fig:figures_processMessages}
\end{figure}

\subsubsection{Optimizations}

limit bandwidth 
    - should be made dynamic
    
    %  It also helps to avoid unwanted message transmission and prevents clogging of networks and conserves bandwidth.
    
queue optimizations (discard duplicate)

easy to implement a vector clock in order to get partial ordering  (message may not be delivered until vector clock is as large)

\subsection{Logic}

    
    \subsubsection{Messages}
    serialized dictionary
    dynamic structure realized by a serialized key-value store. 
    this allows to easily extend the protocol


    \subsubsection{Message handling}
    Strategy pattern, depending on the Key.Command the appropriate handler will be chosen.
    
    \subsubsection{VirtualFileSystem}
    
    observe folder changes
    
    associate files with peers
    
    limitation: no real fs, hence it is possible to invalidate the state of the vfs by modifying the folder when the application is not running. 
    
    \subsubsection{Requesting a file}
    
    direct communication, multicasting files might be inappropriate
    
    \subsubsection{Fault-tolerance Hearbeat}
    toughest challenge in async network, what happens when peer leaves without notice (e.g. crashed). On the one hand, it is not possible to distingush between a crash or a slow peer and  on the other hand there is no automatic mechanism that detects if a peer left a multicast group.
    
    Therefore we implement a (Heartbeat), we favored a heartbeat over a ping tactic because we do not need to elect a leader for that. 
    every peer send a heartbeat every x second with its vector clock (showing its internal message state), if a peer 
    
    this might cause that a peer is temporarily not available also he is functioning properly.
    

    
    
    

\subsection{Interface}